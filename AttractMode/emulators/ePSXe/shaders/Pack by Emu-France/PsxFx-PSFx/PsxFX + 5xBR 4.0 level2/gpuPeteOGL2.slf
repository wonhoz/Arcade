/*===============================================================================*\
|########################   [GLSL PSX FX SHADER V1.30]    ########################|
|########################	   [BY ASMODEAN@PCSX2]	     #########################|
||																				 ||
||			  		   ,---.  .---..-.   .-.  ,---..-.   .-.					 ||
||					   | .-.\( .-._)) \_/ /   | .-' ) \_/ / 					 ||
||					   | |-' )) \  (_)   /    | `-.(_)   /  					 ||
||					   | |--'_ \ \   / _ \    | .-'  / _ \  					 ||
||					   | | ( `-'  ) / / ) \   | |   / / ) \ 					 ||
||					   /(   `----' `-' (_)-'  )\|  `-' (_)-'					 ||
||					  (__)                   (__)           					 ||
||																				 ||
||		  This program is free software; you can redistribute it and/or			 ||
||		  modify it under the terms of the GNU General Public License			 ||
||		  as published by the Free Software Foundation; either version 2		 ||
||		  of the License, or (at your option) any later version.				 ||
||																				 ||
||		  This program is distributed in the hope that it will be useful,		 ||
||		  but WITHOUT ANY WARRANTY; without even the implied warranty of		 ||
||		  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the			 ||
||		  GNU General Public License for more details.							 ||
||																				 ||
|#################################################################################|
\*===============================================================================*/
#version 330 compatibility

/*------------------------------------------------------------------------------
								[EXTENSIONS]
------------------------------------------------------------------------------*/

#extension GL_NV_gpu_shader5 : enable
#extension GL_ARB_gpu_shader5 : enable
#extension GL_NV_draw_buffers : enable
#extension GL_ARB_draw_buffers : enable
#extension GL_ARB_sample_shading : enable
#extension GL_ARB_shader_precision : enable
#extension GL_ARB_texture_rectangle : enable
#extension GL_ARB_conservative_depth : enable 
#extension GL_ARB_shader_texture_lod : enable
#extension GL_ARB_texture_multisample : enable
#extension GL_ARB_vertex_attrib_64bit : enable
#extension GL_NV_explicit_multisample : enable
#extension GL_ARB_uniform_buffer_object : enable

precision highp int;
precision highp float;

/*------------------------------------------------------------------------------
						[DEFINITIONS & ON/OFF OPTIONS]
------------------------------------------------------------------------------*/

//---------------------------#[CHOOSE EFFECTS]#--------------------------------\\

//-#[ANTIALIASING TECHNIQUES]  [1=ON/0=OFF]  *READ: For best results, only enable one type of AA at one time. (TXFAA & 2DAA require being enabled in the vertex shader(.slv))
#define NFAA_ENABLED				0		//#Normal Filter Anti Aliasing (Subtle AA, with good edge detection, no blur (3D Only)).
#define SSAA_ENABLED				0		//#Shader-Based SuperSampling, Scales well with high resolutions. (Soft SS AA (2D & 3D)).
#define FXAA_ENABLED				0		//#HQ Fast Approximate Anti Aliasing (Heavy duty AA, more blur than the others, but also better jaggy removal. (2D & 3D)).
#define TXFAA_ENABLED				0		//#Texture Filtering-based Anti Aliasing. (Smooth looking, nice for both 2D & 3D games)|READ:**To enable this, you also need to set it to 1 in the Vertex shader (.slv)**||
#define SPRITE_INTERPOLATION		        1		//#2DAA Interpolation Smoothing, Nice for Sprite games(2D only)|READ:**To enable this, you also need to set it to 1 in the Vertex shader (.slv)**||

//-#[LIGHTING & COLOUR] 	   [1=ON/0=OFF]  *READ: These can all be turned on & off independently of each other. || For HDR - the luma, tonemap, and bloom passes should be used together, for best results.
#define LUMA_SHARPEN				1		//#HQ luma-based sharpen, looks similar to a negative mip LOD Bias, enhances texture fidelity. 
#define HDR_BLOOM_PASS				1 		//#Bloom high pass of the HDR.
#define HDR_GAMMA_PASS				1		//#Scene gamma correction pass of the HDR.
#define HDR_TONEMAP_PASS			1		//#Scene color correction & intelligent tonemapping pass of the HDR.
#define INTELLI_VIBRANCE			1		//#Dynamic per pixel vibrance. Intelligently adjusts colors depending on their original saturation.
#define S_CURVE_CONTRAST			1		//#S-Curve Scene Contrast Enhancement.
#define LIGHT_ATTENUATION			1		//#Light Attenuation, simulates calculation of light/illum for each pixel on screen(lighting enhancement).
#define SUBPIXEL_DITHERING			1		//#Subpixel Dithering, Smoothes gradiants, this can help to reduce color banding.
#define CRT_EMULATION				0		//#Simulates CRT TV display. Note: Interferes with antialiasing & other effects.

//-#[TEXTURE FILTERING] 	   [1=ON/0=OFF]  *READ: The use of filters requires an AA technique to be turned on. For best results, only enable one type of Filter at one time.
#define TEXTURE_FILTER_ENABLED		1		//#<-**Don't turn this off, for now**. Enable or Disable The texture filtering from the two options below.
#define FILTER_TYPE_BICUBIC			0		//#CatMullRom BiCubic texture filter ||Choose one type of filter, don't enable both together.||
#define FILTER_TYPE_BILINEAR		0		//#BiLinear texture filter (recommended) ||Choose one type of filter, don't enable both together.||

/*------------------------------------------------------------------------------
					[SHADER FX CONFIG OPTIONS & LOCAL VARS]
------------------------------------------------------------------------------*/

//-[NFAA OPTIONS]
#if (NFAA_ENABLED == 1)
	float filterStrength = 10.0;			//AA Strength 
	float filterSpread = 0.20;				//Filter Width	
	bool useColor = false;					//Uses color detection, instead of luma edge detection (more coverage, less accuracy).
	bool debug = false;						//Shows the edge detection.
#endif

//-[SSAA OPTIONS]
#if (SSAA_ENABLED == 1)
	float FilterWidth = 1.0; 				//Filter Width
#endif

//-[FXAA OPTIONS]
#if (FXAA_ENABLED == 1)
	#define FXAA_SPAN_MAX (2)				//Amount of subpixel aliasing removal. 0 = off. Higher values = (softer). Lower values = (crisper)
	#define FXAA_REDUCE_MIN (0.003f)		//FXAA aliasing reduction min. best leave this as it is.
	#define FXAA_REDUCE_MUL (0.063f)		//FXAA aliasing reduction mul. best leave this as it is.
#endif

//-[SHARPEN OPTIONS]
#if (LUMA_SHARPEN == 1)
	#define Sharp_Strength 0.40   			//[0.10 to 3.00]
	#define Sharp_Clamp 0.015  				//[0.000 to 1.000]
	#define Pattern 5 						//1 = Normal, 2 = Wider, 3 = Pyramid shaped, 4 = 9-tap guassian, 5 = HQ 9-tap texture fetch.
	#define Offset_Bias 4.0 				//Offset Bias [0.0 to 6.0] Lower values result in a crisper sharpened look, higher results in a softer texture detail enhancement
	#define Show_Sharpen 0					//shows the sharpen effect. mainly for debugging purposes.
#endif

//-[BLOOM OPTIONS]
#if (HDR_BLOOM_PASS == 1)
	#define BloomType BlendScreen			//The type of blend for the bloom -[BlendScreen, BlendOverlay, BlendSoftLight] (Default: BlendScreen)
	#define BloomPower 0.300f     			//[0.100 to 0.900] Strength of the bloom. blooms naturally, per environment. You will need to adjust for each bloom type.
	#define BlurSpread 1.000f    			//[0.000 to 4.000] Width of the blooms' 'glow' filtering. 0.000 = off.
#endif

//-[TONEMAP OPTIONS]
#if (HDR_TONEMAP_PASS == 1)
	#define TonemappingType 0				//The type of tonemapping used. 0 = Scene tonemapping, most compatible (Default). 1 = local tonemapping, can be more accurate, but it can look odd, in games with low resolution textures.
	#define BlackLevel 0.038f				//black levels (Tonemapping Shadow correction) Adjust by small amounts, eg: increments of 0.01	
	#define Luma 100.00f					//Luma Percent Avg Correction(luma correction) Higher values = more luma, lower = less luma. Adjust by small amounts, eg: increments of 1
	#define Exposure 100.00f				//White Percent Avg Correction (brightness correction) Higher values = more exposure, lower = less exposure. Adjust by small amounts, eg: increments of 1
	#define WhitePoint 1.00f				//Whitepoint Avg (fog correction) Adjust by small amounts, eg: increments of 0.01
#endif

//-[GAMMA OPTIONS]
#if (HDR_GAMMA_PASS == 1)
	const float Luminance = 1.000;			//Luma
	const float lumaFactor = 1.000;			//Luma Scale Factor
	const float Gamma = 2.2f;  				//Gamma Value. generally best left at 2.2
#endif

#if (S_CURVE_CONTRAST == 1)
	#define CurveType 0						//[0|1|2] Choose what to apply contrast to. 0 = Luma, 1 = Chroma, 2 = both Luma and Chroma. Default is 0 (Luma)
	#define CurvesContrast 0.33				//[-1.00 to 1.00] The amount of contrast you want
	#define CurvesFormula 1					//[1|2] The contrast s-curve you want to use.
#endif

//-[VIBRANCE OPTIONS]
#if (INTELLI_VIBRANCE == 1)
	#define Vibrance 0.02 					//[-1.00 to 1.00] Intelligently saturates (or desaturates if you use negative values) the pixels depending on their original saturation.
#endif

//-[DITHER OPTIONS]
#if (SUBPIXEL_DITHERING == 1)
	#define DitherMethod 2  				//[1 or 2] 1 = Ordering dithering (good and very fast), 2 = Random dithering (even better dithering but not as fast)
#endif

//-[CRT OPTIONS]
#if (CRT_EMULATION == 1)
	#define phase 0.0						// Adjusts the vertical position of scanlines.
	#define inputGamma 2.2					// SRGB 2.2 Gamma for linear blending
	#define outputGamma 2.2					// Simulate a CRT gamma of eg: 2.5 for CRT 'older' look.
	#define distortion 0.000				// Controls the intensity of the barrel distortion used to emulate the CRT "fishbowl effect"
#endif
//-END OF USER OPTIONS.

/*------------------------------------------------------------------------------
							[GLOBAL VARIABLES]
------------------------------------------------------------------------------*/

uniform vec4 OGL2Param;
uniform vec4 OGL2Size;
uniform vec4 OGL2InvSize;

uniform sampler2D colorSampler;
uniform sampler2D phongSampler;
uniform sampler2D LumaSampler;
uniform sampler2D AvgLumSampler;
uniform sampler2D txRelLumAvgSampler;
uniform samplerBuffer lumCurveSampler;

vec2 texcoord = gl_TexCoord[0].st;

layout(location = 0) out vec4 SV_Target0;
layout(location = 1) out vec4 SV_Target1;
layout(location = 2) out vec4 SV_Target2;

/*------------------------------------------------------------------------------
                       [TEXTURE FILTER FUNCTIONS]
------------------------------------------------------------------------------*/

#if (TEXTURE_FILTER_ENABLED == 1)
uniform float fWidth = 4096.0;	 //Filter X res
uniform float fHeight = 2048.0;	 //Filter Y res

vec4 cubic(float x)
{
    float x2 = x * x;
    float x3 = x2 * x;
    vec4 w;
    w.x =   -x3 + 3*x2 - 3*x + 1;
    w.y =  3*x3 - 6*x2       + 4;
    w.z = -3*x3 + 3*x2 + 3*x + 1;
    w.w =  x3;
    return w / 6.f;
}

float CatMullRom(float x)
{
    float B = 0.0;
    float C = 0.5;
    float f = x;
	
    if(f < 0.0)
    {
        f = -f;
    }
    if(f < 1.0)
    {
        return ((12.0 - 9.0 * B - 6.0 * C) * (f * f * f) + 
		(-18.0f + 12.0f * B + 6.0f * C) * (f * f) + 
		(6.0f - 2.0f * B)) / 6.0f;
    }
    else if(f >= 1.0 && f < 2.0)
    {
        return (( -B - 6 * C) * (f * f * f) + 
		(6 * B + 30 * C) * (f *f) + 
		(-(12 * B) - 48 * C) * f + 8 * B + 24 * C)/ 6.0;
    }
    else
    {
        return 0.0;
    }
}

#if (FILTER_TYPE_BICUBIC == 1)
vec4 BiCubic(sampler2D textureSampler, vec2 TexCoord)
{
	float texelSizeX = (1.0 / fWidth); //size of one texel 
	float texelSizeY = (1.0 / fHeight); //size of one texel
	
    vec4 nSum = vec4( 0.0, 0.0, 0.0, 0.0 );
    vec4 nDenom = vec4( 0.0, 0.0, 0.0, 0.0 );
	
    float a = fract( TexCoord.x * fWidth ); // get the decimal part
    float b = fract( TexCoord.y * fHeight ); // get the decimal part

	int nX = int(TexCoord.x * fWidth);
	int nY = int(TexCoord.y * fHeight);
	
	vec2 TexCoord1 = vec2( float(nX) / fWidth + 0.5 / fWidth,
					       float(nY) / fHeight + 0.5 / fHeight );

    for(int m = -1; m <=2; m++)
    {
        for(int n =-1; n<= 2; n++)
        {
			vec4 vecData = texture(textureSampler, TexCoord1 + vec2(texelSizeX * float( m ), texelSizeY * float( n )));
			float f  = CatMullRom( float( m ) - a );
			vec4 vecCooef1 = vec4( f,f,f,f );
			float f1 = CatMullRom( -( float( n ) - b ) );
			vec4 vecCoeef2 = vec4( f1, f1, f1, f1 );
            nSum = nSum + ( vecData * vecCoeef2 * vecCooef1  );
            nDenom = nDenom + (( vecCoeef2 * vecCooef1 ));
        }
    }
    return nSum / nDenom;
}
#endif
#if (FILTER_TYPE_BILINEAR == 1)
vec4 tex2DBiLinear(sampler2D textureSampler_i, vec2 texCoord_i)
{	
	float texelSizeX = (1.0 / fWidth); //size of one texel 
	float texelSizeY = (1.0 / fHeight); //size of one texel 

	int nX = int( texCoord_i.x * fWidth );
	int nY = int( texCoord_i.y * fHeight );
	
	vec2 texCoord_New = vec2( ( float( nX ) + 0.5 ) / fWidth,
							  ( float( nY ) + 0.5 ) / fHeight );
	// Take nearest two data in current row.
    vec4 p0q0 = texture(textureSampler_i, texCoord_New);
    vec4 p1q0 = texture(textureSampler_i, texCoord_New + vec2(texelSizeX, 0));

	// Take nearest two data in bottom row.
    vec4 p0q1 = texture(textureSampler_i, texCoord_New + vec2(0, texelSizeY));
    vec4 p1q1 = texture(textureSampler_i, texCoord_New + vec2(texelSizeX , texelSizeY));

    float a = fract(texCoord_i.x * fWidth); // Get Interpolation factor for X direction.
											 // Fraction near to valid data.
	// Interpolation in X direction.
    vec4 pInterp_q0 = mix( p0q0, p1q0, a ); // Interpolates top row in X direction.
    vec4 pInterp_q1 = mix( p0q1, p1q1, a ); // Interpolates bottom row in X direction.

    float b = fract(texCoord_i.y * fHeight); // Get Interpolation factor for Y direction.
	
    return mix(pInterp_q0, pInterp_q1, b); // Interpolate in Y direction.
}
#endif
#endif

/*------------------------------------------------------------------------------
                       [COLOR CORRECTION FUNCTIONS]
------------------------------------------------------------------------------*/

#define GammaCorrection(color, gamma) pow(color, gamma)
#define InverseGammaCorrection(color, gamma) pow(color, 1.0f/gamma)

float RGBLuminance(vec4 color)
{
   vec3 lumCoeff = vec3(0.212656, 0.715158, 0.072186);
   color.a = dot(color.rgb, lumCoeff);
   return color.a;
}

float BlendScreen(float base, float blend)
{
	return (1.0f - ((1.0f - base) * (1.0f - blend)));
}

#define BlendOverlay(base, blend) 	(base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend)))
#define BlendSoftLight(base, blend) ((blend < 0.5) ? (2.0 * base * blend + base * base * (1.0 - 2.0 * blend)) : (sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend)))

/*------------------------------------------------------------------------------
                             [NFAA CODE SECTION]
------------------------------------------------------------------------------*/

#if (NFAA_ENABLED == 1)
vec2 rcpres = vec2(OGL2InvSize.x, OGL2InvSize.y);

	float GetColorLuminance(vec3 i_vColor)
	{
		return dot(i_vColor, vec3(0.2126f, 0.7152f, 0.0722f));
	}

	vec2 findContrastByLuminance(vec2 XYCoord) 
	{
		// Normal offsets, scale by filter spread
		vec2 upOffset = vec2( 0, rcpres.y ) * filterSpread;
		vec2 rightOffset = vec2( rcpres.x, 0 ) * filterSpread;

		float topHeight         = GetColorLuminance( texture( colorSampler, XYCoord + upOffset              ).rgb );
		float bottomHeight      = GetColorLuminance( texture( colorSampler, XYCoord - upOffset              ).rgb );
		float rightHeight       = GetColorLuminance( texture( colorSampler, XYCoord + rightOffset           ).rgb );
		float leftHeight        = GetColorLuminance( texture( colorSampler, XYCoord - rightOffset           ).rgb );
		float leftTopHeight     = GetColorLuminance( texture( colorSampler, XYCoord - rightOffset + upOffset).rgb );
		float leftBottomHeight  = GetColorLuminance( texture( colorSampler, XYCoord - rightOffset - upOffset).rgb );
		float rightBottomHeight = GetColorLuminance( texture( colorSampler, XYCoord + rightOffset + upOffset).rgb );
		float rightTopHeight    = GetColorLuminance( texture( colorSampler, XYCoord + rightOffset - upOffset).rgb );

		// Normal map creation
		float sum0 = rightTopHeight    + bottomHeight + leftTopHeight;
		float sum1 = leftBottomHeight  + topHeight    + rightBottomHeight;
		float sum2 = leftTopHeight     + rightHeight  + leftBottomHeight;
		float sum3 = rightBottomHeight + leftHeight   + rightTopHeight;

		// Subtract the opposite sample set for final vectors
		float vector1 = (sum0 - sum1) * filterStrength;
		float vector2 = (sum3 - sum2) * filterStrength;

		vec2 Vectors = vec2(vector1, vector2);

		return Vectors;
	}

	vec2 findContrastByColor(vec2 XYCoord)
	{
		// Normal offsets, scale by filter spread
		vec2 upOffset = vec2( 0, rcpres.y ) * filterSpread;
		vec2 rightOffset = vec2( rcpres.x, 0 ) * filterSpread;

		vec3 topHeight         = texture( colorSampler, XYCoord + upOffset              ).rgb;
		vec3 bottomHeight      = texture( colorSampler, XYCoord - upOffset              ).rgb;
		vec3 rightHeight       = texture( colorSampler, XYCoord + rightOffset           ).rgb;
		vec3 leftHeight        = texture( colorSampler, XYCoord - rightOffset           ).rgb;
		vec3 leftTopHeight     = texture( colorSampler, XYCoord - rightOffset + upOffset).rgb;
		vec3 leftBottomHeight  = texture( colorSampler, XYCoord - rightOffset - upOffset).rgb;
		vec3 rightBottomHeight = texture( colorSampler, XYCoord + rightOffset + upOffset).rgb;
		vec3 rightTopHeight    = texture( colorSampler, XYCoord + rightOffset - upOffset).rgb;

		// Normal map creation
		vec3 sum0 = rightTopHeight    + bottomHeight + leftTopHeight;
		vec3 sum1 = leftBottomHeight  + topHeight    + rightBottomHeight;
		vec3 sum2 = leftTopHeight     + rightHeight  + leftBottomHeight;
		vec3 sum3 = rightBottomHeight + leftHeight   + rightTopHeight;

		// Subtract the opposite sample set for final vectors
		float vector1 = length(sum0 - sum1) * filterStrength;
		float vector2 = length(sum3 - sum2) * filterStrength;

		vec2 Vectors = vec2(vector1, vector2);

		return Vectors;
	}

	vec4 NFAAPass(vec4 o_Color, vec2 Vectors) 
	{
		
		filterStrength += (filterSpread/2);
		
		if (useColor)
		{ 
			Vectors = findContrastByColor(texcoord.xy);
		}
		else
		{
			Vectors = findContrastByLuminance(texcoord.xy);
		}

		float filterClamp = filterStrength/filterSpread;

		Vectors.xy = clamp(Vectors, -vec2(filterClamp,filterClamp), vec2(filterClamp,filterClamp));

		vec2 Normal = vec2(Vectors.x, Vectors.y) * rcpres;
		
		#if (TEXTURE_FILTER_ENABLED == 1 && FILTER_TYPE_BICUBIC == 1)
			vec4 Scene0 = BiCubic(colorSampler, texcoord.xy);
			vec4 Scene1 = texture(colorSampler, texcoord.xy + Normal.xy, 0.0);
			vec4 Scene2 = texture(colorSampler, texcoord.xy - Normal.xy, 0.0);
			vec4 Scene3 = texture(colorSampler, texcoord.xy + vec2(Normal.x, -Normal.y), 0.0);
			vec4 Scene4 = texture(colorSampler, texcoord.xy - vec2(Normal.x, -Normal.y), 0.0);
		#elif (TEXTURE_FILTER_ENABLED == 1 && FILTER_TYPE_BILINEAR == 1)
			vec4 Scene0 = tex2DBiLinear(colorSampler, texcoord.xy);
			vec4 Scene1 = texture(colorSampler, texcoord.xy + Normal.xy, 0.0);
			vec4 Scene2 = texture(colorSampler, texcoord.xy - Normal.xy, 0.0);
			vec4 Scene3 = texture(colorSampler, texcoord.xy + vec2(Normal.x, -Normal.y), 0.0);
			vec4 Scene4 = texture(colorSampler, texcoord.xy - vec2(Normal.x, -Normal.y), 0.0);
		#else
			vec4 Scene0 = texture(colorSampler, texcoord.xy, 0.0);
			vec4 Scene1 = texture(colorSampler, texcoord.xy + Normal.xy, 0.0);
			vec4 Scene2 = texture(colorSampler, texcoord.xy - Normal.xy, 0.0);
			vec4 Scene3 = texture(colorSampler, texcoord.xy + vec2(Normal.x, -Normal.y), 0.0);
			vec4 Scene4 = texture(colorSampler, texcoord.xy - vec2(Normal.x, -Normal.y), 0.0);
		#endif

		// Final color
		o_Color = (Scene0 + Scene1 + Scene2 + Scene3 + Scene4) * 0.2;

		// Debug Output
		if (debug) 
		{
			o_Color .xyz = normalize(vec3(Vectors.x, Vectors.y, 1.0) * 0.5 + 0.5);
		}

		return o_Color;
	}
#endif

/*------------------------------------------------------------------------------
                             [SSAA CODE SECTION]
------------------------------------------------------------------------------*/

#if (SSAA_ENABLED == 1)
vec2 inverse_buffer_size = vec2(OGL2InvSize.x, OGL2InvSize.y);

	float lumRGB(vec3 v)
	{   
		return dot(v, vec3(0.2126f, 0.7152f, 0.0722f));
	}
	
	vec4 SSAAPass(vec4 oColor, vec2 txCoord) 
	{
	 
		float   t = lumRGB(texture(colorSampler, texcoord + vec2(0.0, -1.0) * FilterWidth * inverse_buffer_size, 0.0).xyz),
				l = lumRGB(texture(colorSampler, texcoord + vec2(-1.0, 0.0) * FilterWidth * inverse_buffer_size, 0.0).xyz),
				r = lumRGB(texture(colorSampler, texcoord + vec2(1.0, 0.0) * FilterWidth * inverse_buffer_size, 0.0).xyz),
				b = lumRGB(texture(colorSampler, texcoord + vec2(0.0, 1.0) * FilterWidth * inverse_buffer_size, 0.0).xyz);
	 
		vec2    n = vec2(-(t - b), r - l);

		float   nl = length(n);
		
		if	(nl < (1.0 / 16.0))
			return texture(colorSampler, texcoord, 0.0);
	 
		else
		{
			n *= inverse_buffer_size / nl;
			
			#if (TEXTURE_FILTER_ENABLED == 1 && FILTER_TYPE_BICUBIC == 1)
				vec4	o = BiCubic(colorSampler, texcoord),
						t0 = texture(colorSampler, texcoord + n * 0.5, 0.0) * 0.9,
						t1 = texture(colorSampler, texcoord - n * 0.5, 0.0) * 0.9,
						t2 = texture(colorSampler, texcoord + n, 0.0) * 0.75,
						t3 = texture(colorSampler, texcoord - n, 0.0) * 0.75; 
			#elif (TEXTURE_FILTER_ENABLED == 1 && FILTER_TYPE_BILINEAR == 1)
				vec4	o = tex2DBiLinear(colorSampler, texcoord),
						t0 = tex2DBiLinear(colorSampler, texcoord + n * 0.5) * 0.9,
						t1 = texture(colorSampler, texcoord - n * 0.5, 0.0) * 0.9,
						t2 = texture(colorSampler, texcoord + n, 0.0) * 0.75,
						t3 = texture(colorSampler, texcoord - n, 0.0) * 0.75; 
			#else
				vec4	o = texture(colorSampler, texcoord, 0.0),
						t0 = texture(colorSampler, texcoord + n * 0.5, 0.0) * 0.9,
						t1 = texture(colorSampler, texcoord - n * 0.5, 0.0) * 0.9,
						t2 = texture(colorSampler, texcoord + n, 0.0) * 0.75,
						t3 = texture(colorSampler, texcoord - n, 0.0) * 0.75; 
			#endif						
					
			oColor = (o + t0 + t1 + t2 + t3) / 4.3;
			
			return oColor;
	}
	}
#endif

/*------------------------------------------------------------------------------
                    [TXFAA AA CODE SECTION]
------------------------------------------------------------------------------*/

#if (TXFAA_ENABLED == 1)
vec4 TXFAAPass(vec4 color, vec2 texcoord)
{
	vec3 c00 = texture2D(colorSampler, gl_TexCoord[5].xy).xyz; 
	vec3 c10 = texture2D(colorSampler, gl_TexCoord[1].xy).xyz; 
	vec3 c20 = texture2D(colorSampler, gl_TexCoord[2].zw).xyz; 
	vec3 c01 = texture2D(colorSampler, gl_TexCoord[3].xy).xyz; 
	vec3 c11 = texture2D(colorSampler, gl_TexCoord[0].xy).xyz; 
	vec3 c21 = texture2D(colorSampler, gl_TexCoord[4].xy).xyz; 
	vec3 c02 = texture2D(colorSampler, gl_TexCoord[1].zw).xyz; 
	vec3 c12 = texture2D(colorSampler, gl_TexCoord[2].xy).xyz; 
	vec3 c22 = texture2D(colorSampler, gl_TexCoord[6].xy).xyz; 
	vec3 dt = vec3(1.0,1.0,1.0); 

	float d1=1.0/(dot(abs(c00-c22),dt)+0.00001);
	float d2=1.0/(dot(abs(c20-c02),dt)+0.00001);
	float hl=1.0/(dot(abs(c01-c21),dt)+0.00001);
	float vl=1.0/(dot(abs(c10-c12),dt)+0.00001);

	c11 = 0.3333*((vl*(c10+c12)+hl*(c01+c21)+d2*(c20+c02)+d1*(c00+c22))/(hl+vl+d1+d2)+c11);

	d1 = length(c11);
	color.xyz=c11;
	
	return color;
}
#endif

/*------------------------------------------------------------------------------
                    [SPRITE INTERPOLATION AA CODE SECTION]
------------------------------------------------------------------------------*/

#if (SPRITE_INTERPOLATION == 1)

/*
   Hyllian's 5xBR v4.0 (LEVEL 2) + NV Shader - ported to GLSL by guest(r)
   Copyright (C) 2011/2014 Hyllian/Jararaca - sergiogdb@gmail.com


   This program is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2
   of the License, or (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/



const   float XBR_SCALE = 3.0;

const   float coef          = 2.0;
const   vec3  rgbw          = vec3(14.352, 28.176, 5.472);
const   vec4  eq_threshold  = vec4(15.0, 15.0, 15.0, 15.0);


const   vec2 OGLSize    = vec2( 1024.0, 512.0);
const   vec2 OGLInvSize = vec2( 0.0009765625, 0.001953125); 
const   vec2 dx         = vec2( 0.0009765625, 0.0);
const   vec2 dy         = vec2( 0.0, 0.001953125 );
const   vec2 x2         = vec2( 0.001953125 , 0.0);
const   vec2 y2         = vec2( 0.0 , 0.00390625 );
const   vec4 xy         = vec4( 0.0009765625, 0.001953125,-0.0009765625,-0.001953125);  
const   vec4 zw         = vec4( 0.001953125 , 0.001953125,-0.001953125 ,-0.00390625 );  
const   vec4 wz         = vec4( 0.0009765625, 0.00390625 ,-0.0009765625,-0.00390625 );  


vec4 noteq(vec4 A, vec4 B)
{
	return vec4(notEqual(A, B));
}

vec4 not(vec4 A)
{
	return vec4(1.0)-A;
}

vec4 df(vec4 A, vec4 B)
{
    return abs(A-B);
}

vec4 eq(vec4 A, vec4 B)
{
return vec4(lessThan(df(A, B),eq_threshold));
}


vec4 weighted_distance(vec4 a, vec4 b, vec4 c, vec4 d, vec4 e, vec4 f, vec4 g, vec4 h)
{
    return (df(a,b) + df(a,c) + df(d,e) + df(d,f) + 4.0*df(g,h));
}


float c_df(vec3 c1, vec3 c2) {
                        vec3 df = abs(c1 - c2);
                        return df.r + df.g + df.b;
                }
				



vec3 texture2d (vec2 texcoord) {

    vec4 edr, edr_left, edr_up;                     // px = pixel, edr = edge detection rule
    vec4 interp_restriction_lv1, interp_restriction_lv2_left, interp_restriction_lv2_up;
    vec4 nc30, nc60, nc45;                          // new_color
    vec4 fx, fx_left, fx_up, final_fx;              // inequations of straight lines.
    vec3 res1, res2, pix1, pix2;
    bvec4 nc, px;
    float blend1, blend2; 

    vec4 delta  = vec4(1.0/XBR_SCALE, 1.0/XBR_SCALE, 1.0/XBR_SCALE, 1.0/XBR_SCALE);
    vec4 deltaL = vec4(0.5/XBR_SCALE, 1.0/XBR_SCALE, 0.5/XBR_SCALE, 1.0/XBR_SCALE);
    vec4 deltaU = deltaL.yxwz;


    vec2 fp  = fract(texcoord*OGLSize);
    vec2 TexCoord_0 = texcoord-fp*OGLInvSize + 0.5*OGLInvSize;


    vec3 A  = texture2D(colorSampler, TexCoord_0 + xy.zw ).xyz;
    vec3 B  = texture2D(colorSampler, TexCoord_0     -dy ).xyz;
    vec3 C  = texture2D(colorSampler, TexCoord_0 + xy.xw ).xyz;
    vec3 D  = texture2D(colorSampler, TexCoord_0 - dx    ).xyz;
    vec3 E  = texture2D(colorSampler, TexCoord_0         ).xyz;
    vec3 F  = texture2D(colorSampler, TexCoord_0 + dx    ).xyz;
    vec3 G  = texture2D(colorSampler, TexCoord_0 + xy.zy ).xyz;
    vec3 H  = texture2D(colorSampler, TexCoord_0     +dy ).xyz;
    vec3 I  = texture2D(colorSampler, TexCoord_0 + xy.xy ).xyz;
    vec3 A1 = texture2D(colorSampler, TexCoord_0 + wz.zw ).xyz;
    vec3 C1 = texture2D(colorSampler, TexCoord_0 + wz.xw ).xyz;
    vec3 A0 = texture2D(colorSampler, TexCoord_0 + zw.zw ).xyz;
    vec3 G0 = texture2D(colorSampler, TexCoord_0 + zw.zy ).xyz;
    vec3 C4 = texture2D(colorSampler, TexCoord_0 + zw.xw ).xyz;
    vec3 I4 = texture2D(colorSampler, TexCoord_0 + zw.xy ).xyz;
    vec3 G5 = texture2D(colorSampler, TexCoord_0 + wz.zy ).xyz;
    vec3 I5 = texture2D(colorSampler, TexCoord_0 + wz.xy ).xyz;
    vec3 B1 = texture2D(colorSampler, TexCoord_0 - y2    ).xyz;
    vec3 D0 = texture2D(colorSampler, TexCoord_0 - x2    ).xyz;
    vec3 H5 = texture2D(colorSampler, TexCoord_0 + y2    ).xyz;
    vec3 F4 = texture2D(colorSampler, TexCoord_0 + x2    ).xyz;

    vec4 b  = vec4(dot(B ,rgbw), dot(D ,rgbw), dot(H ,rgbw), dot(F ,rgbw));
    vec4 c  = vec4(dot(C ,rgbw), dot(A ,rgbw), dot(G ,rgbw), dot(I ,rgbw));
    vec4 d  = b.yzwx;
    vec4 e  = vec4(dot(E,rgbw));
    vec4 f  = b.wxyz;
    vec4 g  = c.zwxy;
    vec4 h  = b.zwxy;
    vec4 i  = c.wxyz;
    vec4 i4 = vec4(dot(I4,rgbw), dot(C1,rgbw), dot(A0,rgbw), dot(G5,rgbw));
    vec4 i5 = vec4(dot(I5,rgbw), dot(C4,rgbw), dot(A1,rgbw), dot(G0,rgbw));
    vec4 h5 = vec4(dot(H5,rgbw), dot(F4,rgbw), dot(B1,rgbw), dot(D0,rgbw));
    vec4 f4 = h5.yzwx;
    vec4 c1 = i4.yzwx;
    vec4 g0 = i5.wxyz;
    
    vec4 Ao = vec4( 1.0, -1.0, -1.0, 1.0 );
    vec4 Bo = vec4( 1.0,  1.0, -1.0,-1.0 );
    vec4 Co = vec4( 1.5,  0.5, -0.5, 0.5 );
    vec4 Ax = vec4( 1.0, -1.0, -1.0, 1.0 );
    vec4 Bx = vec4( 0.5,  2.0, -0.5,-2.0 );
    vec4 Cx = vec4( 1.0,  1.0, -0.5, 0.0 );
    vec4 Ay = vec4( 1.0, -1.0, -1.0, 1.0 );
    vec4 By = vec4( 2.0,  0.5, -2.0,-0.5 );
    vec4 Cy = vec4( 2.0,  0.0, -1.0, 0.5 );
    
// These inequations define the line below which interpolation occurs.
	
    fx      = (Ao*fp.y+Bo*fp.x); 
	
    fx_left = (Ax*fp.y+Bx*fp.x);
	
    fx_up   = (Ay*fp.y+By*fp.x);

    if (OGL2Param.z == 0.0)
    {    interp_restriction_lv1 = sign(noteq(e,f) * noteq(e,h));}

    if (OGL2Param.z == 1.0)
    {    interp_restriction_lv1 = sign(noteq(e,f) * noteq(e,h) * ( not(eq(f,b)) * not(eq(h,d)) + eq(e,i) * not(eq(f,i4)) * not(eq(h,i5)) + eq(e,g) + eq(e,c)));}

    if (OGL2Param.z == 2.0)
    {    interp_restriction_lv1 = sign(noteq(e,f)*noteq(e,h)*(not(eq(f,b))* not(eq(h,d)) + eq(e,i) * not(eq(f,i4)) * not(eq(h,i5)) + eq(e,g) + eq(e,c) )  * (noteq(f,f4)* noteq(f,i) + noteq(h,h5) * noteq(h,i) + noteq(h,g) + noteq(f,c) + eq(b,c1) * eq(d,g0)));}

    if (OGL2Param.z == 3.0)
    {    interp_restriction_lv1 = sign(noteq(e,f) * noteq(e,h) * ( not(eq(f,b)) * not(eq(f,c)) + not(eq(h,d)) * not(eq(h,g)) + eq(e,i) * (not(eq(f,f4)) * not(eq(f,i4)) + not(eq(h,h5)) * not(eq(h,i5))) + eq(e,g) + eq(e,c)) );}

    interp_restriction_lv2_left = vec4(notEqual(e,g))*vec4(notEqual(d,g));
    interp_restriction_lv2_up   = vec4(notEqual(e,c))*vec4(notEqual(b,c));

    vec4 fx45 = clamp((fx + delta -Co)/(2*delta ),0.0,1.0);
    vec4 fx30 = clamp((fx_left + deltaL -Cx)/(2*deltaL),0.0,1.0);
    vec4 fx60 = clamp((fx_up + deltaU -Cy)/(2*deltaU),0.0,1.0);
	
    edr      = vec4(lessThan(weighted_distance( e, c, g, i, h5, f4, h, f), weighted_distance( h, d, i5, f, i4, b, e, i)))*interp_restriction_lv1;
    edr_left = vec4(lessThanEqual(coef*df(f,g),df(h,c)))*interp_restriction_lv2_left*edr; 
    edr_up   = vec4(greaterThanEqual(df(f,g),coef*df(h,c)))*interp_restriction_lv2_up*edr;

    fx45 = edr*fx45;
    fx30 = edr_left*fx30;
    fx60 = edr_up*fx60;

    px = lessThanEqual(df(e,f),df(e,h));
    vec4 maximo = max(max(fx30, fx60), fx45);    

    mat4x3 pix = mat4x3(mix(E, mix(H, F, float(px.x)), maximo.x), 
                        mix(E, mix(F, B, float(px.y)), maximo.y),
                        mix(E, mix(B, D, float(px.z)), maximo.z),
                        mix(E, mix(D, H, float(px.w)), maximo.w));

    vec4 pixel = vec4(dot(pix[0],rgbw),dot(pix[1],rgbw),dot(pix[2],rgbw),dot(pix[3],rgbw));

    vec4 diff = df(pixel,e);

    vec3 res = pix[0];
    float mx = diff.x;

    if (diff.y > mx) {res = pix[1]; mx = diff.y;}
    if (diff.z > mx) {res = pix[2]; mx = diff.z;}
    if (diff.w > mx) {res = pix[3];} 


    return res;    
}



vec4 SpritePass(vec4 SpriteColor, vec2 txCoord)
	{	
		/*This code is courtesy of guest.r*/


		vec3 c11 = texture2d(gl_TexCoord[0].xy).xyz;
		SpriteColor = vec4(c11, 1.0);
	 
		return SpriteColor;
	} 
#endif

/*------------------------------------------------------------------------------
                             [FXAA CODE SECTION]
------------------------------------------------------------------------------*/

#if (FXAA_ENABLED == 1)
#define FXAA_QUALITY__PS 	13
#define FXAA_QUALITY__P0 	1.0
#define FXAA_QUALITY__P1 	1.0
#define FXAA_QUALITY__P2 	1.0
#define FXAA_QUALITY__P11	1.0
#define FXAA_GATHER4_ALPHA 1
#define FXAA_QUALITY__SUBPIX (0.5)
#define FXAA_QUALITY__EDGE_THRESHOLD (0.063)
#define FXAA_QUALITY__EDGE_THRESHOLD_MIN (0.0312)

in vec4 posPos;
#define FxaaInt2 ivec2
#define Fxaavec2 vec2
#define Fxaavec4 vec4
#define FxaaSat(x) clamp(x, 0.0, 1.0)
#define FxaaLerp(x,y,s) mix(x,y,s)
#define FxaaTexLod0(t, p) textureLod(t, p, 0.0)
#define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)
#define FxaaTexAlpha4(t, p, r) textureGather(t, p, 3)
#define FxaaTexOffAlpha4(t, p, o, r) textureGatherOffset(t, p, o, 3)
	
	vec3 FxaaPixelShader(vec4 posPos, sampler2D tex, vec2 rcpFrame)
	{	
		vec2 posM;
		posM.x = posPos.x;
		posM.y = posPos.y;
		
		#if (GL_NV_gpu_shader5)
		vec4 luma4A = FxaaTexAlpha4(tex, posM, rcpFrame.xy);
		vec4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1), rcpFrame.xy);
		#endif
		
		vec4 rgbyM = FxaaTexLod0(tex, posM);
 
        float lumaS = FxaaTexOff(tex, posM, FxaaInt2( 0, 1), rcpFrame.xy).w;
        float lumaE = FxaaTexOff(tex, posM, FxaaInt2( 1, 0), rcpFrame.xy).w;
        float lumaN = FxaaTexOff(tex, posM, FxaaInt2( 0,-1), rcpFrame.xy).w;
        float lumaW = FxaaTexOff(tex, posM, FxaaInt2(-1, 0), rcpFrame.xy).w;
		
		vec3 rgbNW = FxaaTexLod0(tex, posPos.zw).xyz;
		vec3 rgbNE = FxaaTexOff(tex, posPos.zw, FxaaInt2(1,0), rcpFrame.xy).xyz;
		vec3 rgbSW = FxaaTexOff(tex, posPos.zw, FxaaInt2(0,1), rcpFrame.xy).xyz;
		vec3 rgbSE = FxaaTexOff(tex, posPos.zw, FxaaInt2(1,1), rcpFrame.xy).xyz;
		vec3 rgbM  = FxaaTexLod0(tex, posPos.xy).xyz;

		vec3 luma = vec3(0.2125, 0.7154, 0.0721);
		float lumaNW = dot(rgbNW, luma);
		float lumaNE = dot(rgbNE, luma);
		float lumaSW = dot(rgbSW, luma);
		float lumaSE = dot(rgbSE, luma);
		float lumaM  = dot(rgbM,  luma);
		
		float maxSM = max(lumaS, lumaM);
		float minSM = min(lumaS, lumaM);
		float maxESM = max(lumaE, maxSM);
		float minESM = min(lumaE, minSM);
		float maxWN = max(lumaN, lumaW);
		float minWN = min(lumaN, lumaW);
		float rangeMax = max(maxWN, maxESM);
		float rangeMin = min(minWN, minESM);
		float rangeMaxScaled = rangeMax * FXAA_QUALITY__EDGE_THRESHOLD;
		float range = rangeMax - rangeMin;
		float rangeMaxClamped = max(FXAA_QUALITY__EDGE_THRESHOLD_MIN, rangeMaxScaled);
		bool earlyExit = range < rangeMaxClamped;
		
		float lumaNS = lumaN + lumaS;
		float lumaWE = lumaW + lumaE;
		float subpixRcpRange = 1.0/range;
		float subpixNSWE = lumaNS + lumaWE;
		float edgeHorz1 = (-2.0 * lumaM) + lumaNS;
		float edgeVert1 = (-2.0 * lumaM) + lumaWE;

		float lumaNESE = lumaNE + lumaSE;
		float lumaNWNE = lumaNW + lumaNE;
		float edgeHorz2 = (-2.0 * lumaE) + lumaNESE;
		float edgeVert2 = (-2.0 * lumaN) + lumaNWNE;

		float lumaNWSW = lumaNW + lumaSW;
		float lumaSWSE = lumaSW + lumaSE;
		float edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);
		float edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);
		float edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;
		float edgeVert3 = (-2.0 * lumaS) + lumaSWSE;
		float edgeHorz = abs(edgeHorz3) + edgeHorz4;
		float edgeVert = abs(edgeVert3) + edgeVert4;
		
		float subpixNWSWNESE = lumaNWSW + lumaNESE;
		float lengthSign = rcpFrame.x;
		bool horzSpan = edgeHorz >= edgeVert;
		float subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;
		
		if(!horzSpan) lumaN = lumaW;
		if(!horzSpan) lumaS = lumaE;
		if(horzSpan) lengthSign = rcpFrame.y;
		float subpixB = (subpixA * (1.0/12.0)) - lumaM;
		
		float gradientN = lumaN - lumaM;
		float gradientS = lumaS - lumaM;
		float lumaNN = lumaN + lumaM;
		float lumaSS = lumaS + lumaM;
		bool pairN = abs(gradientN) >= abs(gradientS);
		float gradient = max(abs(gradientN), abs(gradientS));
		if(pairN) lengthSign = -lengthSign;
		float subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);
		
		vec2 posB;
		posB.x = posM.x;
		posB.y = posM.y;
		vec2 offNP;
		offNP.x = (!horzSpan) ? 0.0 : rcpFrame.x;
		offNP.y = ( horzSpan) ? 0.0 : rcpFrame.y;
		if(!horzSpan) posB.x += lengthSign * 0.5;
		if( horzSpan) posB.y += lengthSign * 0.5;
		
		vec2 posN;
		posN.x = posB.x - offNP.x * FXAA_QUALITY__P0;
		posN.y = posB.y - offNP.y * FXAA_QUALITY__P0;
		vec2 posP;
		posP.x = posB.x + offNP.x * FXAA_QUALITY__P0;
		posP.y = posB.y + offNP.y * FXAA_QUALITY__P0;
		float subpixD = ((-2.0)*subpixC) + 3.0;
		float lumaEndN = FxaaTexLod0(tex, posN).w;
		float subpixE = subpixC * subpixC;
		float lumaEndP = FxaaTexLod0(tex, posP).w;
		
		if(!pairN) lumaNN = lumaSS;
		float gradientScaled = gradient * 1.0/4.0;
		float lumaMM = lumaM - lumaNN * 0.5;
		float subpixF = subpixD * subpixE;
		bool lumaMLTZero = lumaMM < 0.0;
		
		lumaEndN -= lumaNN * 0.5;
		lumaEndP -= lumaNN * 0.5;
		bool doneN = abs(lumaEndN) >= gradientScaled;
		bool doneP = abs(lumaEndP) >= gradientScaled;
		if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P1;
		if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P1;
		bool doneNP = (!doneN) || (!doneP);
		if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P1;
		if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P1;
		
		if(doneNP)
		{
			if(!doneN) lumaEndN = FxaaTexLod0(tex, posN.xy).w;
			if(!doneP) lumaEndP = FxaaTexLod0(tex, posP.xy).w;
			if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
			if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
			doneN = abs(lumaEndN) >= gradientScaled;
			doneP = abs(lumaEndP) >= gradientScaled;
			if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P11;
			if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P11;
			doneNP = (!doneN) || (!doneP);
			if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P11;
			if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P11;
		}
		
		float dstN = posM.x - posN.x;
		float dstP = posP.x - posM.x;
		if(!horzSpan) dstN = posM.y - posN.y;
		if(!horzSpan) dstP = posP.y - posM.y;
		
		bool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;
		float spanLength = (dstP + dstN);
		bool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;
		float spanLengthRcp = 1.0/spanLength;

		bool directionN = dstN < dstP;
		float dst = min(dstN, dstP);
		bool goodSpan = directionN ? goodSpanN : goodSpanP;
		float subpixG = subpixF * subpixF;
		float pixelOffset = (dst * (-spanLengthRcp)) + 0.5;
		float subpixH = subpixG * FXAA_QUALITY__SUBPIX;

		float pixelOffsetGood = goodSpan ? pixelOffset : 0.0;
		float pixelOffsetSubpix = max(pixelOffsetGood, subpixH);
		if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;
		if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;

		float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
		float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

		vec2 dir; 
		dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
		dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

		float dirReduce = max(
			(lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * 
			FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);
		float rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);
		dir = min(Fxaavec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX), 
			  max(Fxaavec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX), 
			  dir * rcpDirMin)) * rcpFrame.xy;

		vec3 rgbA = (1.0/2.0) * (
			FxaaTexLod0(tex, posPos.xy + dir * (1.0/3.0 - 0.5)).xyz +
			FxaaTexLod0(tex, posPos.xy + dir * (2.0/3.0 - 0.5)).xyz);
		vec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (
			FxaaTexLod0(tex, posPos.xy + dir * (0.0/3.0 - 0.5)).xyz +
			FxaaTexLod0(tex, posPos.xy + dir * (3.0/3.0 - 0.5)).xyz);
		float lumaB = dot(rgbB, luma);
		
		if((lumaB < lumaMin) || (lumaB > lumaMax)) return rgbA;
		return rgbB;
	}

	vec4 DoFXAA(sampler2D FxaaTex, vec2 texcoord)
	{
		vec4 FxaaColor = texture(colorSampler, texcoord);
		vec2 rcpFrame = vec2(OGL2InvSize.x, OGL2InvSize.y);
		
		FxaaColor.rgb = FxaaPixelShader(posPos, FxaaTex, rcpFrame);
		FxaaColor.a = dot(FxaaColor.rgb, vec3(0.212656, 0.715158, 0.072186));
		
		return FxaaColor;
	}
	
	vec4 FXAAPass(vec4 FxaaColor, vec2 texcoord) 
	{
		return DoFXAA(colorSampler, texcoord);
	}

#endif

/*------------------------------------------------------------------------------
                          [LUMA SHARPEN CODE SECTION]
------------------------------------------------------------------------------*/

#if (LUMA_SHARPEN == 1)
	#define BUFFER_RCP_WIDTH (1.0 / 3584)
	#define BUFFER_RCP_HEIGHT (1.0 / 3072)
	#define px BUFFER_RCP_WIDTH
	#define py BUFFER_RCP_HEIGHT
	#define pixel vec2(px,py)
	#define CoefLuma vec3(0.2126, 0.7152, 0.0722)
	#define sharp_strength_luma (CoefLuma * Sharp_Strength)
	
	vec4 LumaSharpen(vec4 color, vec2 tex) 
	{
		vec3 ori = texture(colorSampler, tex).rgb; 

		// -- Pattern 1 -- A 9 tap gaussian using 4+1 texture fetches.
		#if (Pattern == 1)
			vec3 blur_ori = texture(colorSampler, tex + vec2(px,-py) * 0.5 * Offset_Bias).rgb;
			blur_ori += texture(colorSampler, tex + vec2(-px,-py) * 0.5 * Offset_Bias).rgb;   
			blur_ori += texture(colorSampler, tex + vec2(px,py) * 0.5 * Offset_Bias).rgb;
			blur_ori += texture(colorSampler, tex + vec2(-px,py) * 0.5 * Offset_Bias).rgb;

			blur_ori *= 0.25;
		#endif 

		// -- Pattern 2 -- An experimental 17 tap gaussian using 4+1 texture fetches.
		#if (Pattern == 2)
			vec3 blur_ori = texture(colorSampler, tex + vec2(0.4*px,-1.2*py)* Offset_Bias).rgb;
			blur_ori += texture(colorSampler, tex + vec2(-1.2*px,-0.4*py) * Offset_Bias).rgb;
			blur_ori += texture(colorSampler, tex + vec2(1.2*px,0.4*py) * Offset_Bias).rgb;
			blur_ori += texture(colorSampler, tex + vec2(-0.4*px,1.2*py) * Offset_Bias).rgb;
			blur_ori *= 0.25;

			sharp_strength_luma *= 0.51;
		#endif

		// -- Pattern 3 -- A 9 tap high pass (pyramid filter) using 4+1 texture fetches.
		#if (Pattern == 3)
			vec3 blur_ori = texture(colorSampler, tex + vec2(0.5 * px,-py * Offset_Bias)).rgb;
			blur_ori += texture(colorSampler, tex + vec2(Offset_Bias * -px,0.5 * -py)).rgb;
			blur_ori += texture(colorSampler, tex + vec2(Offset_Bias * px,0.5 * py)).rgb;
			blur_ori += texture(colorSampler, tex + vec2(0.5 * -px,py * Offset_Bias)).rgb;	
			blur_ori /= 4.0;

			sharp_strength_luma *= 0.666;
		#endif

		// -- Pattern 4 -- A (slower) 9 tap gaussian using 9 texture fetches.
		#if (Pattern == 4)
			half3 blur_ori = texture(colorSampler, tex + vec2(-px,py) * Offset_Bias).rgb;
			blur_ori += texture(colorSampler, tex + vec2(px,-py) * Offset_Bias).rgb;
			blur_ori += texture(colorSampler, tex + vec2(-px,-py)  * Offset_Bias).rgb;
			blur_ori += texture(colorSampler, tex + vec2(px,py) * Offset_Bias).rgb;

			half3 blur_ori2 = texture(colorSampler, tex + vec2(0,py) * Offset_Bias).rgb;
			blur_ori2 += texture(colorSampler, tex + vec2(0,-py) * Offset_Bias).rgb;
			blur_ori2 += texture(colorSampler, tex + vec2(-px,0) * Offset_Bias).rgb;
			blur_ori2 += texture(colorSampler, tex + vec2(px,0) * Offset_Bias).rgb;
			blur_ori2 *= 2.0;

			blur_ori += blur_ori2;
			blur_ori += (ori * 4);
			blur_ori /= 16.0;
		#endif

		// -- Pattern 5 -- A (slower) 9 tap high pass using 9 texture fetches.
		#if (Pattern == 5)
			vec3 blur_ori = texture(colorSampler, tex + vec2(-px,py) * Offset_Bias).rgb;
			blur_ori += texture(colorSampler, tex + vec2(px,-py) * Offset_Bias).rgb;
			blur_ori += texture(colorSampler, tex + vec2(-px,-py)  * Offset_Bias).rgb;
			blur_ori += texture(colorSampler, tex + vec2(px,py) * Offset_Bias).rgb;

			blur_ori += ori.rgb;

			blur_ori += texture(colorSampler, tex + vec2(0,py) * Offset_Bias).rgb;
			blur_ori += texture(colorSampler, tex + vec2(0,-py) * Offset_Bias).rgb;
			blur_ori += texture(colorSampler, tex + vec2(-px,0) * Offset_Bias).rgb;
			blur_ori += texture(colorSampler, tex + vec2(px,0) * Offset_Bias).rgb;

			blur_ori /= 9;
		#endif

		vec3 sharp = ori - blur_ori;
		
		float sharp_luma = dot(sharp, sharp_strength_luma);
		sharp_luma = clamp(sharp_luma, -Sharp_Clamp, Sharp_Clamp);
		
		color.rgb = color.rgb + sharp_luma;
		color.a = RGBLuminance(color); 

		#if Show_Sharpen == 1
		done = clamp(0.5 + (sharp_luma * 4), 0.0, 1.0).rrrr;
		#endif

		return clamp(color, 0.0, 1.0);
	}
#endif

/*------------------------------------------------------------------------------
                       [CRT EMULATION CODE SECTION]
------------------------------------------------------------------------------*/

#if (CRT_EMULATION == 1)
	vec2 TextureSize = OGL2Size.xy;
	vec2 InputSize = vec2(320.0f, 240.0f);
	vec2 OutputSize = vec2(800.0f, 600.0f);
	#define TEX2D(c) pow(texture(colorSampler, (c)), vec4(inputGamma))                
	#define FIX(c)   max(abs(c), 1e-6);
	#define Pi 3.141592653589

	// Apply radial distortion to the given coordinate.
	vec2 radialDistortion(vec2 coord) {
			coord *= TextureSize / InputSize;
			vec2 cc = coord - 0.5;
			float dist = dot(cc, cc) * distortion;                
			return (coord + cc * (1.0 + dist) * dist) * InputSize / TextureSize;
	}

	vec4 scanlineWeights(float distance, vec4 color)
	{
			// The "width" of the scanline beam is set as 2*(1 + x^4) for
			// each RGB channel.
			vec4 wid = 2.0 + 2.0 * pow(color, vec4(4.0));

			vec4 weights = vec4(distance * 3.333333);                
			return 0.51 * exp(-pow(weights * sqrt(2.0 / wid), wid)) / (0.18 + 0.06 * wid);
	}
			
	vec4 CRTPass(vec4 color, vec2 texcoord)
	{
			// The size of one texel, in texture-coordinates.
			vec2 one = 1.0 / TextureSize;

			// Texture coordinates of the texel containing the active pixel                
			vec2 xy = radialDistortion(texcoord);

			// Of all the pixels that are mapped onto the texel we are
			// currently rendering, which pixel are we currently rendering?
			vec2 uv_ratio = fract(xy * TextureSize) - vec2(0.5);

			// Snap to the center of the underlying texel.                
			xy = (floor(xy * TextureSize) + vec2(0.5)) / TextureSize;               
			vec4 coeffs = Pi * vec4(1.0 + uv_ratio.x, uv_ratio.x, 1.0 - uv_ratio.x, 2.0 - uv_ratio.x);                                
			
			// Prevent division by zero
			coeffs = FIX(coeffs);
			coeffs = 2.0 * sin(coeffs) * sin(coeffs / 2.0) / (coeffs * coeffs);
			
			// Normalize
			coeffs /= dot(coeffs, vec4(1.0));                                
			vec4 col  = clamp(coeffs.x * TEX2D(xy + vec2(-one.x, 0.0))   
			+ coeffs.y * TEX2D(xy) + coeffs.z * TEX2D(xy + vec2(one.x, 0.0)) 
			+ coeffs.w * TEX2D(xy + vec2(2.0 * one.x, 0.0)),   0.0, 1.0);
			vec4 col2 = clamp(coeffs.x * TEX2D(xy + vec2(-one.x, one.y)) 
			+ coeffs.y * TEX2D(xy + vec2(0.0, one.y)) + coeffs.z * TEX2D(xy + one) 
			+ coeffs.w * TEX2D(xy + vec2(2.0 * one.x, one.y)), 0.0, 1.0);

			vec4 weights  = scanlineWeights(abs(uv_ratio.y) , col);
			vec4 weights2 = scanlineWeights(1.0 - uv_ratio.y, col2);
			vec3 mul_res  = (col * weights + col2 * weights2).xyz;

			// mod_factor is the x-coordinate of the current output pixel.
			float mod_factor = texcoord.x * OutputSize.x * TextureSize.x / InputSize.x;
			
			// dot-mask emulation:
			// Output pixels are alternately tinted green and magenta.
			vec3 dotMaskWeights = mix(vec3(1.05, 0.75, 1.05), vec3(0.75, 1.05, 0.75), floor(mod(mod_factor, 2.0)));
				
			mul_res *= dotMaskWeights;
			
			// Convert the image gamma for display on our output device.
			mul_res = pow(mul_res, vec3(1.0 / (2.0 * inputGamma - outputGamma)));
			
			color.rgb = mul_res;
			color.a = RGBLuminance(color);
			return color;
	}
#endif

/*------------------------------------------------------------------------------
						[DYNAMIC VIBRANCE CODE SECTION]
------------------------------------------------------------------------------*/

#if (INTELLI_VIBRANCE == 1)
	vec4 VibrancePass(vec4 vibranceColor, vec2 t)
	{
		vec4 color = vibranceColor; //original input color
		vec3 lumCoeff = vec3(0.2126, 0.7152, 0.0722);  //Values to calculate luma with

		float luma = dot(lumCoeff, color.rgb); //calculate luma (grey)
		
		float max_color = max(vibranceColor.r, max(vibranceColor.g,vibranceColor.b)); //Find the strongest color
		float min_color = min(vibranceColor.r, min(vibranceColor.g,vibranceColor.b)); //Find the weakest color
		
		float color_saturation = max_color - min_color; //The difference between the two is the saturation
	  
		color.rgb = mix(vec3(luma), color.rgb, (1.0 + (Vibrance * (1.0 - (sign(Vibrance) * color_saturation))))); //extrapolate between luma and original by 1 + (1-saturation) - current
		color.a = RGBLuminance(vibranceColor);
	  
		return color; //return the result
	}
#endif

/*------------------------------------------------------------------------------
                        [HDR BLOOM PASS CODE SECTION]
------------------------------------------------------------------------------*/

#if (HDR_BLOOM_PASS == 1)
const float blurspread = BlurSpread;

	vec4 BloomPass(vec4 color, vec2 t)
	{	
		float bloomPower = BloomPower;
		vec4 blur = texture(colorSampler, t);
		blur = color * 0.22520613262190495;

		vec2 dx = vec2(OGL2InvSize.x * blurspread, 0.0);
		vec2 dy = vec2(0.0, OGL2InvSize.y * 2.0 * blurspread);
		vec2 dx2 = 2 * dx;
		vec2 dy2 = 2 * dy;
		
		vec4 colorU = texture(colorSampler, t + dy);
		
		blur += 0.002589001911021066 * texture(colorSampler, t -dx2 +dy2); 
		blur += 0.010778807494659370 * texture(colorSampler, t -dx +dy2); 
		blur += 0.024146616900339800 * texture(colorSampler, t +dy2); 
		blur += 0.010778807494659370 * texture(colorSampler, t +dx +dy2); 
		blur += 0.002589001911021066 * texture(colorSampler, t +dx2 +dy2); 

		blur += 0.010778807494659370 * texture(colorSampler, t -dx2 +dy);
		blur += 0.044875475183061630 * texture(colorSampler, t -dx +dy);
		blur += 0.100529757860782610 * texture(colorSampler, t +dy);
		blur += 0.044875475183061630 * texture(colorSampler, t +dx +dy);
		blur += 0.010778807494659370 * texture(colorSampler, t +dx2 +dy);

		blur += 0.024146616900339800 * texture(colorSampler, t -dx2);
		blur += 0.100529757860782610 * texture(colorSampler, t -dx);	
		blur += 0.100529757860782610 * texture(colorSampler, t +dx);
		blur += 0.024146616900339800 * texture(colorSampler, t +dx2);

		blur += 0.010778807494659370 * texture(colorSampler, t -dx2 -dy);
		blur += 0.044875475183061630 * texture(colorSampler, t -dx -dy);
		blur += 0.100529757860782610 * texture(colorSampler, t -dy);
		blur += 0.044875475183061630 * texture(colorSampler, t +dx -dy);
		blur += 0.010778807494659370 * texture(colorSampler, t +dx2 -dy);

		blur += 0.002589001911021066 * texture(colorSampler, t -dx2 -dy2);
		blur += 0.010778807494659370 * texture(colorSampler, t -dx -dy2);
		blur += 0.024146616900339800 * texture(colorSampler, t -dy2);
		blur += 0.010778807494659370 * texture(colorSampler, t +dx -dy2);
		blur += 0.002589001911021066 * texture(colorSampler, t +dx2 -dy2);				
		
		vec4 newcolor = vec4(BloomType(color.r, blur.r),
							 BloomType(color.g, blur.g),
							 BloomType(color.b, blur.b),
							 RGBLuminance(color));
		
		color = mix(color, newcolor, BloomPower);
		color.a = RGBLuminance(color);
	
		return color;
	}
#endif

/*------------------------------------------------------------------------------
					[HDR GAMMA CORRECTION PASS CODE SECTION]
------------------------------------------------------------------------------*/

#if (HDR_GAMMA_PASS == 1)
	uniform float key;
	uniform float threshold;
	uniform float phi;

	#define DO_TONEMAP
	#define DO_GLOBAL
	#define DO_LOCAL
	#define DO_CHROMINANCE
	#define DO_VARYING
	#define K 4
	
	vec3 RGB2XYZ(const vec3 RGB)
	{
	  const mat3 mRGB2XYZ = mat3
	  (
		vec3(0.51413640, 0.26506800, 0.02411880),
		vec3(0.32387860, 0.67023428, 0.12281780),
		vec3(0.16036376, 0.06409157, 0.84442666)
	  );
	  vec3 XYZ = mRGB2XYZ * RGB;
	  return(XYZ);
	}
	
	vec3 XYZ2RGB(const vec3 XYZ)
	{
	  const mat3 mXYZ2RGB = mat3
	  (
		vec3( 2.5651, -1.0217,  0.0753),
		vec3(-1.1665,  1.9777, -0.2543),
		vec3(-0.3986,  0.0439,  1.1892)
	  );
	  vec3 RGB = mXYZ2RGB * XYZ;
	  return(RGB);
	}
	
	struct Yxy_t
	{
	  float Y;
	  float x;
	  float y;
	};

	Yxy_t XYZ2Yxy(const vec3 XYZ)
	{
	  Yxy_t Yxy;
	  float W = XYZ.x + XYZ.y + XYZ.z;
	  Yxy.Y = XYZ.y;
	  Yxy.x = XYZ.x / W;
	  Yxy.y = XYZ.y / W;
	  return(Yxy);
	}

	Yxy_t RGB2Yxy(const vec3 RGB)
	{
	  vec3 XYZ = RGB2XYZ(RGB);
	  Yxy_t Yxy = XYZ2Yxy(XYZ);
	  return(Yxy);
	}

	vec3 Yxy2XYZ(const Yxy_t Yxy)
	{
	  vec3 XYZ;
	  XYZ.x = Yxy.Y * (Yxy.x / Yxy.y);
	  XYZ.y = Yxy.Y;
	  XYZ.z = (XYZ.x / Yxy.x) - XYZ.x - XYZ.y;
	  return(XYZ);
	}

	vec3 Yxy2RGB(const Yxy_t Yxy)
	{
	  vec3 XYZ = Yxy2XYZ(Yxy);
	  vec3 RGB = XYZ2RGB(XYZ);
	  return(RGB);
	}

	struct Lab_t
	{
	  float L;
	  float a;
	  float b;
	};

	const vec3 D50 = vec3( 96.4212, 100.0, 82.51880 );
	const vec3 D55 = vec3( 95.6797, 100.0, 92.14810 );
	const vec3 D65 = vec3( 95.0429, 100.0, 108.8900 );
	const vec3 D75 = vec3( 94.9722, 100.0, 122.6394 );

	const float e = 216.0 / 24389.0;
	const float k = 24389.0 / 27.0;
	
	Lab_t XYZ2Lab(const vec3 XYZ)
	{
	  const vec3 W = D65;

	  const vec3 r = XYZ / W;

	  vec3 f;
	  f.x = (r.x > e) ? pow(r.x, 1.0/3.0) : (k*r.x + 16.0)/116.0;
	  f.y = (r.y > e) ? pow(r.y, 1.0/3.0) : (k*r.y + 16.0)/116.0;
	  f.z = (r.z > e) ? pow(r.z, 1.0/3.0) : (k*r.z + 16.0)/116.0;

	  Lab_t Lab;
	  Lab.L = 116.0*f.y - 16.0;
	  Lab.a = 500.0*(f.x - f.y);
	  Lab.b = 200.0*(f.y - f.z);

	  return(Lab);
	}

	vec3 Lab2XYZ(const Lab_t Lab)
	{
	  const vec3 W = D65;

	  vec3 f;
	  f.y = (Lab.L + 16.0) / 116.0;
	  f.x = (Lab.a/500.0) + f.y;
	  f.z = f.y - (Lab.b/200.0);

	  vec3 r;
	  r.x = (pow(f.x, 3.0) > e) ? pow(f.x, 3.0) : (116.0*f.x - 16.0)/k;
	  r.y = (pow(f.y, 3.0) > e) ? pow(f.y, 3.0) : Lab.L / k;
	  r.z = (pow(f.z, 3.0) > e) ? pow(f.z, 3.0) : (116.0*f.z - 16.0)/k;

	  vec3 XYZ;
	  XYZ = r * W;

	  return(XYZ);
	}

	Lab_t RGB2Lab(const vec3 RGB)
	{
	  vec3 XYZ = RGB2XYZ(RGB);
	  Lab_t Lab = XYZ2Lab(XYZ);
	  return(Lab);
	}

	vec3 Lab2RGB(const Lab_t Lab)
	{
	  vec3 XYZ = Lab2XYZ(Lab);
	  vec3 RGB = XYZ2RGB(XYZ);
	  return(RGB);
	}

	Lab_t Yxy2Lab(const Yxy_t Yxy)
	{
	  vec3 XYZ = Yxy2XYZ(Yxy);
	  Lab_t Lab = XYZ2Lab(XYZ);
	  return(Lab);
	}

	Yxy_t Lab2Yxy(const Lab_t Lab)
	{
	  vec3 XYZ = Lab2XYZ(Lab);
	  Yxy_t Yxy = XYZ2Yxy(XYZ);
	  return(Yxy);
	}

	float E(const float I)
	{
	  return( ((70.0)/(1.0 + pow(10.0/I, 0.383))) + 22.0 );
	}

	void ChrominanceAdaption(inout vec3 XYZ, const float lambda)
	{
	  Lab_t Lab = XYZ2Lab(XYZ);
	  float rho = min(E(lambda)/E(10.0), 1.0);
	  if (Lab.a > 0.0)
		Lab.a *= rho;
	  XYZ = Lab2XYZ(Lab);
	}

	float RelativeLuminance(const float lum, const float key, const float logavglum)
	{
	  float rLum = (lum*key) / logavglum;
	  return(rLum);
	}

	float Global(const float lum, const float rLum)
	{
	  float dLum = rLum / (1.0+rLum);
	  return(dLum);
	}
	
	#define vec float
	#define EXT r
	#define sampler sampler2DRect
	#define texFetch texture2DRect

	uniform sampler txSATLum;
	uniform vec2 SATSIZE;

	vec texSATArea(const sampler SAT, vec2 amin, vec2 amax, out vec2 area)
	{
	  amax = min(amax, SATSIZE-vec2(0.5));
	  vec accum = texFetch(SAT, amax).EXT;
	  amin = max(amin, vec2(0.5));
	  amin -= vec2(1);
	  accum -= texFetch(SAT, vec2(amin.x,amax.y)).EXT;
	  accum -= texFetch(SAT, vec2(amax.x,amin.y)).EXT;
	  accum += texFetch(SAT, amin).EXT;
	  area = vec2(amax.x-amin.x, amax.y-amin.y);
	  return(accum);
	}

	vec texSATDiff(const sampler SAT, vec2 center, vec2 diff, out vec2 area)
	{
	  vec2 amin = center-diff;
	  vec2 amax = center+diff;
	  vec sum = texSATArea(SAT, amin, amax, area);
	  return(sum);
	}
	
	float Activity(const float Aa, const float Bb, const float ii, const float kkey, const float pphi)
	{
	  float scale = pow(1.6, ii);
	  float num = (Aa - Bb);
	  float sharp = pow(2.0, pphi)*kkey;
	  float denum = (sharp/(scale*scale))+Aa;
	  float activity = abs(num/denum);
	  return(activity);
	}
	
	float LumScale(const sampler SAT, vec2 coord, const int i)
	{
	  //const int sizes [8] = { 1, 3, 5, 7, 11, 17, 27, 43 };
	  const int radii [8] = int[]( 0, 1, 2, 3, 5, 8, 13, 21 );
	  vec2 area;
	  float lum = texSATDiff(SAT, coord, vec2(radii[i]), area);
	  lum /= (area.x*area.y);
	  return(lum);
	}

	#define SCALES 8
	vec3 MaxScaleLuminance(const sampler SAT, vec2 coord, const float rLum)
	{
	  float lums [8];
	  lums[0] = rLum;

	  float add_back = texture(txRelLumAvgSampler, vec2(0.0)).r;

	  for (int i=SCALES-1; i>0; --i)
		lums[i] = LumScale(SAT, coord, i) + add_back;

	  vec3 lummax = vec3(lums[SCALES-1], SCALES-1, 1.0);
	  for (int i=0; i<SCALES-1; ++i)
	  {
		float activity = Activity(lums[i], lums[i+1], i, key, phi);
		if (activity > threshold)
		{
		  #if (GL_NV_gpu_shader5)
			lummax = vec3(lums[i], i, float(i)/float(SCALES-1)); //intelligent method (works on NVIDIA)
			break;
		  #else
		  if (lummax.x == lums[SCALES-1])
			lummax = vec3(lums[i], i, float(i)/float(SCALES-1)); //Radeon-friendly.
		  #endif
		}
	  }

	  return(lummax);
	}

	float Local(const float lum, const float rLum, const float maxlum)
	{
	  float dLum = rLum / (1.0+maxlum);
	  return(dLum);
	}
	
	vec4 LumCorrectPass(vec4 HDRColor, vec2 Tex)
	{		
		vec3 correctedGamma;
		vec3 InverseCorrectedGamma;
		
		Yxy_t Yxy = RGB2Yxy(HDRColor.rgb);
		float rLum = 0.2126;
		float dLum = Yxy.Y;
		vec3 maxLum = vec3(0.0);

		#ifdef DO_TONEMAP
			vec2 avgs = texture(AvgLumSampler, vec2(0.5)).ra;
			float chromaLum = avgs.x;
			rLum = RelativeLuminance(Yxy.Y, key, avgs.y);

		#ifdef DO_GLOBAL
			dLum = Global(Yxy.Y, rLum);
		#endif

		#ifdef DO_LOCAL
			maxLum = MaxScaleLuminance(txSATLum, gl_TexCoord[1].xy, rLum);
			dLum = Local(Yxy.Y, rLum, maxLum.x);

		#ifdef DO_VARYING
			chromaLum = maxLum.x*(avgs.x/key);
		#endif
		#endif

		Yxy.Y = dLum;
		vec3 XYZ = Yxy2XYZ(Yxy);

		#ifdef DO_CHROMINANCE
		  ChrominanceAdaption(XYZ, chromaLum);
		#endif

		HDRColor.rgb + XYZ2RGB(XYZ);
		HDRColor.a = RGBLuminance(HDRColor);
		
		correctedGamma = GammaCorrection(HDRColor.rgb, vec3(Gamma/2.2f));
		InverseCorrectedGamma = InverseGammaCorrection(HDRColor.rgb, vec3(Gamma/2.2f));
		
		HDRColor.rgb = ((correctedGamma+InverseCorrectedGamma)/2);
		clamp(HDRColor, 0.00, 1.0);
		#endif

		return HDRColor;
	}
#endif

/*------------------------------------------------------------------------------
                        [HDR TONEMAP PASS CODE SECTION]
------------------------------------------------------------------------------*/

#if (HDR_TONEMAP_PASS == 1)
	vec4 TonemapPass(vec4 colorInput, vec2 t)
	{
		// Average scene luminance is stored in R channel
		float avgLuminance = Luma;
		float exposure = Exposure;
		float whitePoint = WhitePoint;
		float blackLevel = BlackLevel;

		//TEXCOORD mapping swap
		vec2 colorTexel = vec2(0,0);
		
		#if(TonemappingType == 1)
		// ||Local tone mapping
		vec4 ColorTone = texture(phongSampler, t);
		
		// Detect dark areas, depending on mapping type
		if(ColorTone.r < 0.25f && ColorTone.g < 0.25f && ColorTone.b < 0.25f)
		{
			colorTexel = t;
			ColorTone = texture(phongSampler, colorTexel);
			colorInput.rgb -= blackLevel;
		}
		#else
		// ||Scene tone mapping
		vec4 ColorTone = texture(phongSampler, t);
		
		// Detect dark areas, depending on mapping type
		if(ColorTone.r < 1.00f && ColorTone.g < 1.00f && ColorTone.b < 1.00f)
		{
			colorTexel = t;
			ColorTone = texture(phongSampler, colorTexel);
			colorInput.rgb -= blackLevel;
		}
		#endif

		vec3 lumCoeff = vec3(0.212656f, 0.715158f, 0.072186f);
		
		
		// RGB -> XYZ conversion
		const mat3 RGB2XYZ = mat3(0.4124564f,  0.3575761f,  0.1804375f,
								  0.2126729f,  0.7151522f,  0.0721750f,
								  0.0193339f,  0.1191920f,  0.9503041f);
								  
		vec3 XYZ = colorInput.rgb*RGB2XYZ;
	  
		// XYZ -> Yxy conversion
		vec3 Yxy = lumCoeff;
		Yxy.r = XYZ.g;                            // copy luminance Y
		Yxy.g = XYZ.r / (XYZ.r + XYZ.g + XYZ.b ); // x = X / (X + Y + Z)
		Yxy.b = XYZ.g / (XYZ.r + XYZ.g + XYZ.b ); // y = Y / (X + Y + Z)
		
		// (Lp) Map average luminance to the middlegrey zone by scaling pixel luminance
		float Lp = Yxy.r * exposure / avgLuminance;                       
		// (Ld) Scale all luminance within a displayable range of 0 to 1
		Yxy.r = (Lp * (1.0f + Lp/(whitePoint * whitePoint)))/(1.0f + Lp);
	  
		// Yxy -> XYZ conversion
		XYZ.r = Yxy.r * Yxy.g / Yxy. b;               // X = Y * x / y
		XYZ.g = Yxy.r;                                // copy luminance Y
		XYZ.b = Yxy.r * (1 - Yxy.g - Yxy.b) / Yxy.b;  // Z = Y * (1-x-y) / y
		
		// XYZ -> RGB conversion
		const mat3 XYZ2RGB  = mat3(3.2404542f, -1.5371385f, -0.4985314f,
								  -0.9692660f,  1.8760108f,  0.0415560f, 
								   0.0556434f, -0.2040259f,  1.0572252f);
								   
		colorInput.rgb = XYZ*XYZ2RGB;
		colorInput.a = RGBLuminance(colorInput);
		
		return colorInput;
	}
#endif

/*------------------------------------------------------------------------------
						[DYNAMIC CONTRAST CODE SECTION]
------------------------------------------------------------------------------*/

#if (S_CURVE_CONTRAST == 1)
	vec4 CurvesPass(vec4 colorInput, vec2 t)
	{
		vec3 lumCoeff = vec3(0.212656, 0.715158, 0.072186);
		float Curves_contrast_blend = CurvesContrast;
		float PI = acos(-1); //3.1415926589

		#if (CurveType != 2)
			float luma = dot(lumCoeff, colorInput.rgb);
			vec3 chroma = colorInput.rgb - luma;
		#endif

		#if (CurveType == 2)
			vec3 x = colorInput.rgb;
		#elif (CurveType == 1)
			vec3 x = chroma;
			x = x * 0.5 + 0.5;
		#else
			float x = luma;
		#endif

		// -- Curve 1 -- Cubic Bezier spline
		#if (CurvesFormula == 1)
			float a = 0.00; //start point
			float b = 0.00; //control point 1
			float c = 1.00; //control point 2
			float d = 1.00; //endpoint

			float r  = (1-x);
			float r2 = r*r;
			float r3 = r2 * r;
			float x2 = x*x;
			float x3 = x2*x;

			x = a*(1-x)*(1-x)*(1-x) + 3*b*(1-x)*(1-x)*x + 3*c*(1-x)*x*x + d*x*x*x;
		#endif

		// -- Curve 2 -- Cubic Bezier spline II
		#if (CurvesFormula == 2)
			vec3 a = vec3(0.00,0.00,0.00); //start point
			vec3 b = vec3(0.25,0.15,0.85); //control point 1
			vec3 c = vec3(0.75,0.85,0.15); //control point 2
			vec3 d = vec3(1.00,1.00,1.00); //endpoint

			vec3 ab = mix(a,b,x);           // point between a and b (green)
			vec3 bc = mix(b,c,x);           // point between b and c (green)
			vec3 cd = mix(c,d,x);           // point between c and d (green)
			vec3 abbc = mix(ab,bc,x);       // point between ab and bc (blue)
			vec3 bccd = mix(bc,cd,x);       // point between bc and cd (blue)
			vec3 dest = mix(abbc,bccd,x);   // point on the bezier-curve (black)
			x = dest;
		#endif

		#if (CurveType == 2) //Both Luma and Chroma
			vec3 color = x; 
			colorInput.rgb = mix(colorInput.rgb, color, Curves_contrast_blend);
		#elif (CurveType == 1) //Only Chroma
			x = x * 2 - 1;
			vec3 color = luma + x; //Luma + Chroma
			colorInput.rgb = mix(colorInput.rgb, color, Curves_contrast_blend);
		#else // CurveType == 0 //Only Luma
			x = mix(luma, x, Curves_contrast_blend);
			colorInput.rgb = x + chroma; //Luma + Chroma 
			colorInput.a = RGBLuminance(colorInput);
		#endif

		colorInput = clamp(colorInput, 0.0 , 1.0);
		
		return colorInput;
	}
#endif

/*------------------------------------------------------------------------------
                       [LIGHT ATTENUATION CODE SECTION]
------------------------------------------------------------------------------*/

#if (LIGHT_ATTENUATION == 1)
smooth in vec3 v;
smooth in vec3 N;
 
vec4 LightAtten(vec4 basecolor, vec2 texcoord)
{
	float lightPoint = 0.0333f;
	vec3 L = normalize(gl_LightSource[0].position.xyz - v); 
	vec3 Ee = normalize(-v);
	vec3 R = normalize(-reflect(L,N));
 	vec4 amb, spec, diff;
	vec4 Light = texture2D(phongSampler, texcoord);
 	vec2 light_pos = vec2(0,0);
	amb = gl_FrontLightProduct[0].ambient * gl_FrontMaterial.ambient;
	
	if(basecolor.r > 0.25f && basecolor.g > 0.25f && basecolor.b > 0.25f)
	{
		light_pos = texcoord;
		basecolor.rgb += (Light.rgb*lightPoint);
	}

	spec = gl_FrontLightProduct[0].specular * pow(max(dot(R,Ee),0.0),0.1);
	
	diff = gl_FrontLightProduct[0].diffuse * max(dot(N,L), 0.0);
 
	basecolor = (basecolor) + amb + spec + diff;
	return basecolor;
}

#endif

/*------------------------------------------------------------------------------
                             [DITHER CODE SECTION]
------------------------------------------------------------------------------*/

#if (SUBPIXEL_DITHERING == 1)
	vec4 Dither(vec4 colorInput, vec2 tex)
	{
		
		vec4 color = colorInput;
		vec2 screen_size = vec2(OGL2InvSize.x, OGL2InvSize.y);

		float dither_size = 2.0;  //Size of the dithering grid - I'm using a 2x2 grid here.
		float dither_bit  = 8.0;  //Number of bits per channel. Should be 8 for most monitors.

		#if DitherMethod == 2 //random dithering

		 //make some noise
		 float noise = fract(sin(dot(vec4(tex,-tex.yx), vec4(vec2(12.9898,78.233),vec2(12.9898,78.233)* acos(-1)))) * 43758.5453); //pseudo random number generator
		 
		 noise -= 0.5;
		 
		 //Calculate how big the shift should be
		 float dither_shift = (noise) * (1.0 / (pow(2,dither_bit) - 1.0)); // using noise to determine shift. The noise ahould vary between +- 0.5.
																		   
		 //Shift the individual colors differently, thus making it even harder to see the dithering Pattern
		 vec3 dither_shift_RGB = vec3(-dither_shift, dither_shift, -dither_shift); //subpixel dithering
		 
		 color.rgb += dither_shift_RGB;
		 
		#else //DitherMethod == 1 , Ordered dithering
		 //Calculate grid position
		 float grid_position = fract(dot(tex,(screen_size / dither_size)) + (0.5 / dither_size)); //returns 0.25 and 0.75

		 //Calculate how big the shift should be
		 float dither_shift = (0.25) * (1.0 / (pow(2,dither_bit) - 1.0)); // 0.25 seems good both when using math and when eyeballing it. So does 0.75 btw.

		 //Shift the individual colors differently, thus making it even harder to see the dithering Pattern
		 vec3 dither_shift_RGB = vec3(dither_shift, -dither_shift, dither_shift); //subpixel dithering

		 //modify shift acording to grid position.
		 dither_shift_RGB = mix(2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position); //shift acording to grid position.
		 color.rgb += dither_shift_RGB;
		#endif

		colorInput.rgb = color.rgb;

		return colorInput;
		
	}
#endif

/*------------------------------------------------------------------------------
                      [MAIN() & COMBINE PASS CODE SECTION]
------------------------------------------------------------------------------*/

void main()
{
	vec4 color = texture(colorSampler, texcoord);
	color.a = dot(color.rgb, vec3(0.212656f, 0.715158f, 0.072186f));
	vec4 lumFactor = texture(LumaSampler, texcoord);
	
	#if (NFAA_ENABLED == 1)
		color = NFAAPass(color, texcoord);
	#endif
	
	#if (SSAA_ENABLED == 1)
		color = SSAAPass(color, texcoord);
	#endif
	
	#if (SPRITE_INTERPOLATION == 1)
		color = SpritePass(color, texcoord);
	#endif
	
	#if (FXAA_ENABLED == 1)
		color = FXAAPass(color, texcoord);
	#endif
	
	#if (TXFAA_ENABLED == 1)
		color = TXFAAPass(color, texcoord);
	#endif
	
	#if (CRT_EMULATION == 1)
		color = CRTPass(color, texcoord);
	#endif
	
	#if (LUMA_SHARPEN == 1)
		color = LumaSharpen(color, texcoord);
	#endif
	
	#if (INTELLI_VIBRANCE == 1)
		color = VibrancePass(color, texcoord);
	#endif
	
	#if (HDR_BLOOM_PASS == 1)
		color = BloomPass(color, texcoord);
	#endif
	
	#if (HDR_GAMMA_PASS == 1)
		color = LumCorrectPass(color, texcoord);
	#endif
	
	#if (HDR_TONEMAP_PASS == 1)
		color = TonemapPass(color, texcoord);
	#endif
	
	#if (S_CURVE_CONTRAST == 1)
		color = CurvesPass(color, texcoord);
	#endif
	
	#if (LIGHT_ATTENUATION == 1)
		color = LightAtten(color, texcoord);
	#endif
	
	#if (SUBPIXEL_DITHERING == 1)
		color = Dither(color, texcoord);
	#endif
	
	float lumPoint = dot(color.rgb, vec3(0.2126, 0.7152, 0.0722));
	
	int rOffset = int(color.r * 1024); 
	lumFactor.r = texelFetchBuffer(lumCurveSampler, rOffset).r;
	
	int gOffset = int(color.g * 1024); 
	lumFactor.g = texelFetchBuffer(lumCurveSampler, gOffset).g;

	int bOffset = int(color.b * 1024); 
	lumFactor.b = texelFetchBuffer(lumCurveSampler, bOffset).b;
		
	lumFactor.a = RGBLuminance(color);
	
	SV_Target0 = color;
	SV_Target1 = vec4(lumPoint, lumPoint, lumPoint, RGBLuminance(color));
	SV_Target2 = lumFactor;
}
