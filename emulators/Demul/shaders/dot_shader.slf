/********************/
/* by caligari		*/
/* license: GNU-GPL	*/
/********************/

/*******************************************/
/* Edit this lines to configure the shader */
/*******************************************/

	/* Uncomment this to only process half the screen */
	/* to see how the rendering alters pixels         */	
#define DEBUG

	/* Configure the resolution you'll   */
	/* use when you run Demul            */
vec2 ScreenSize = vec2( 1280.0, 960.0 );

	/* Hardware Size 	                                                  */
	/* if it's too close to your screensize, you won't get much scanlines */
	/* if it's too low, you'll lose definition                            */
vec2 HWSize = vec2( 640.0, 480.0 );
//	vec2 HWSize = ScreenSize / vec2(3.0,3.0);

	/* DOT Size	                                                                       */
	/* Each HW pixel will be rendered as a dot (not exactly a circle, but close enough */
	/* The color fades to black when you get closer to the border of the dot           */
	/* Those two parameters describe the shape of the dot                              */
	/* 0.5 = stay inside the original pixel                                            */
	/* 1.0 = "bleeds" up to the centers of neighbour pixels                            */
	/* For example, with 1.2, you'll get something looking like linear blending        */
	/* With 0.7, you'll get a small scanlines (if your screen res is big enough!)      */
#define DOT_WIDTH	1.2
#define DOT_HEIGHT	0.7

	/* If you want the Barrel Distorsion               */
	/*  -Remove the "//" at the beginning of the line  */
	/*  -Change the amount of distorsion               */
	/*	 smaller number = less distorsion              */
	/*	 0.1 to 0.3 gives correct results              */
#define BARREL_DISTORSION	0.2

	/* Uncomment one of these to choose a gamma correction method. */
	/* If none are uncommented, no gamma correction is done.       */
	/* First one is accurate, but may be slow                      */
	/* Second one is not as accurate, but faster                   */
//#define REAL_GAMMA
#define FAKE_GAMMA
#define InputGamma	2.4
#define OutputGamma	2.2

/********************************/
/* Do not edit after this point */
/********************************/
uniform sampler2D OGL2Texture;
uniform vec4 OGL2Size;



// RubyTextSize = 2048 / Screensize
// Some useful values
vec2 factor = vec2(2048.0) / ScreenSize;
vec2 invfactor = ScreenSize / vec2(2048.0);
vec2 screen2hw = factor * HWSize;
vec2 hw2screen = invfactor / HWSize;

vec2 onex = vec2( hw2screen.x, 0.0 );
vec2 oney = vec2( 0.0, hw2screen.y );

/*********************************************************************************/
/* Some Macros to handle Gamma ***************************************************/
#ifdef	REAL_GAMMA
	#define INPUT_GAMMA(color)		pow(color, vec4( InputGamma ) )
	#define OUTPUT_GAMMA(color) 	pow(color, vec4( 1.0/OutputGamma ) )
#else
	#ifdef FAKE_GAMMA
		vec4 A_IN = vec4( 12.0/(InputGamma+1.0)-3.0 );
        vec4 B_IN = vec4(1.0) - A_IN;
        vec4 A_OUT = vec4( 6.0 - 15 * OutputGamma / 2.0 / (OutputGamma+1.0) );
        vec4 B_OUT = vec4(1.0) - A_OUT;
        #define INPUT_GAMMA(color)     ((A_IN+B_IN*color)*color*color)
        #define OUTPUT_GAMMA(color)    (A_OUT*sqrt(color)+B_OUT*sqrt(sqrt(color)))    
	#else
		#define INPUT_GAMMA(color)	color
		#define OUTPUT_GAMMA(color) color
	#endif FAKE_GAMMA
#endif REAL_GAMMA
/* End of Gamma macros ***********************************************************/
/*********************************************************************************/

/*********************************************************************************/
/* Some Macros/Functions to handle Barrel distorsion *****************************/
#ifdef BARREL_DISTORSION
	vec2 screen_center = vec2(0.5);

	float max_dist = ( 1.0 + (0.25 + BARREL_DISTORSION * 0.25 * 0.25) * BARREL_DISTORSION );
	
	vec2 Barrel( vec2 coords )
	{
		vec2 rel_coords = coords * factor - screen_center;
		float dist = dot(rel_coords, rel_coords);
		vec2 new_coords = rel_coords *
			( 1.0 + (dist + BARREL_DISTORSION * dist * dist) * BARREL_DISTORSION ) / max_dist;

		return (screen_center + new_coords) * invfactor;
	}
#else
	#define Barrel(coords)	coords
#endif BARREL_DISTORSION
/* End of Barrel Macros **********************************************************/
/*********************************************************************************/

// Texture Macro
#define TEX2D(coords)	INPUT_GAMMA( texture2D( OGL2Texture, coords ) )

void main()
{
	vec2 coords = Barrel( gl_TexCoord[0].xy ) * screen2hw;
	vec2 pixel_start = floor( coords );
    coords -= pixel_start;
    vec2 pixel_center = pixel_start + vec2(0.5);
    vec2 texture_coords = pixel_center * hw2screen;

	vec4 output = vec4(0.0);
	vec4 pixel;
	vec3 centers = vec3(-0.25,-0.5,-0.75);
	vec3 posx = vec3( coords.x );
	vec3 hweight;
	float vweight;
	float dx,dy;
	float w;

	int i,j;


	for ( j = -1.0; j<=1.0; j++ )
	{
		// Vertical weight
		dy = abs(coords.y - 0.5 - j );
		vweight = smoothstep(1.0,0.0, dy / DOT_HEIGHT);

		if (vweight !=0.0 )
		{    
			for ( i = -1.0; i<=1.0; i++ )
			{
				pixel = TEX2D( texture_coords + i * onex + j * oney );

				hweight = smoothstep(
					1.0,0.0,
					abs( ( posx + centers - vec3(i) ) / vec3(DOT_WIDTH) )
				);
			output.rgb += pixel.rgb * hweight * vec3(vweight);
			}
		}
	}

	gl_FragColor = clamp( OUTPUT_GAMMA( output ), 0.0, 1.0);

	#ifdef DEBUG
	if (texture_coords.x/texture_coords.y > HWSize.x/HWSize.y)
		gl_FragColor = clamp( OUTPUT_GAMMA( TEX2D( texture_coords) ), 0.0, 1.0);
	#endif DEBUG
}
